<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="mintakeszito.css">
    <style>
        body {
    font-family: Arial, sans-serif;
    /*max-width: 1800px;
    margin: 0 auto;*/
    padding: 20px;
}
.container {
    display: flex;
    flex-direction: column;
}
.controls {
    margin: 20px 0;
}
.pixel-container {
    display: flex;
    flex-wrap: wrap;
    margin-top: 20px;
    border: 1px solid #ccc;
    padding: 10px;
}
.pixel-row {
    display: flex;
    margin-bottom: 5px;
}
.pixel {
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-sizing: border-box;
}
.checkbox-container {
    display: flex;
    align-items: center;
    margin-left: 10px;
}
canvas {
    display: none;
}

.konténer {
--transition: 350ms;
--folder-W: 120px;
--folder-H: 80px;
display: flex;
flex-direction: column;
align-items: center;
justify-content: flex-end;
padding: 10px;
background: linear-gradient(135deg, #6dd5ed, #2193b0);
border-radius: 15px;
box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
height: calc(var(--folder-H) * 1.7);
position: relative;
width: 200px;
}

.folder {
position: absolute;
top: 20px;
left: calc(50% - 60px);
animation: float 2.5s infinite ease-in-out;
transition: transform var(--transition) ease;
}

.folder:hover {
transform: scale(1.05);
}

.folder .front-side,
.folder .back-side {
position: absolute;
transition: transform var(--transition);
transform-origin: bottom center;
}

.folder .back-side::before,
.folder .back-side::after {
content: "";
display: block;
background-color: white;
opacity: 0.5;
z-index: 0;
width: var(--folder-W);
height: var(--folder-H);
position: absolute;
transform-origin: bottom center;
border-radius: 15px;
transition: transform 350ms;
z-index: 0;
}

.konténer:hover .back-side::before {
transform: rotateX(-5deg) skewX(5deg);
}
.konténer:hover .back-side::after {
transform: rotateX(-15deg) skewX(12deg);
}

.folder .front-side {
z-index: 1;
}

.konténer:hover .front-side {
transform: rotateX(-40deg) skewX(15deg);
}

.folder .tip {
background: linear-gradient(135deg, #ff9a56, #ff6f56);
width: 80px;
height: 20px;
border-radius: 12px 12px 0 0;
box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
position: absolute;
top: -10px;
z-index: 2;
}

.folder .cover {
background: linear-gradient(135deg, #ffe563, #ffc663);
width: var(--folder-W);
height: var(--folder-H);
box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
border-radius: 10px;
}

.custom-file-upload {
font-size: 1.1em;
color: #ffffff;
text-align: center;
background: rgba(255, 255, 255, 0.2);
border: none;
border-radius: 10px;
box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
cursor: pointer;
transition: background var(--transition) ease;
display: inline-block;
width: 60%;
padding: 10px 35px;
position: relative;
}

.custom-file-upload:hover {
background: rgba(255, 255, 255, 0.4);
}

.custom-file-upload input[type="file"] {
display: none;
}

@keyframes float {
0% {
transform: translateY(0px);
}

50% {
transform: translateY(-20px);
}

100% {
transform: translateY(0px);
}
}
    </style>
</head>
<body>
    <div class="container">
        
        
            <p>Mintakészítő</p>
            <div class="controls">
                <div class="konténer">
                    <div class="folder">
                    <div class="front-side">
                      <div class="tip"></div>
                      <div class="cover"></div>
                    </div>
                    <div class="back-side cover"></div>
                  </div>
                  <label class="custom-file-upload">
                    <input class="title" type="file" id="imageInput" accept="image/*" />
                    Choose a file
                  </label>
                </div>
                
                <!--<input type="file" id="imageInput" accept="image/*">-->
                <div>
                    <label for="pixelSize">Pixel Size:</label>
                    <input type="range" id="pixelSize" min="10" max="40" value="15">
                    <span id="pixelSizeValue">20</span>
                </div>
                <div>
                    <label for="gridOpacity">Grid Opacity:</label>
                    <input type="range" id="gridOpacity" min="0" max="60" value="20">
                    <span id="gridOpacityValue">30%</span>
                </div>
                <button id="processBtn">Process Image</button>
            </div>
            
            <canvas id="canvas"></canvas>
            <div id="pixelatedImage"></div>
            <div>
            <button id="clearBtn">Clear Saved Image</button>
            </div>
        
    </div>

    <script>

    document.addEventListener('DOMContentLoaded', function() {
        const imageInput = document.getElementById('imageInput');
        const pixelSizeInput = document.getElementById('pixelSize');
        const pixelSizeValue = document.getElementById('pixelSizeValue');
        const gridOpacityInput = document.getElementById('gridOpacity');
        const gridOpacityValue = document.getElementById('gridOpacityValue');
        const processBtn = document.getElementById('processBtn');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const pixelatedImageDiv = document.getElementById('pixelatedImage');
        
        // Update displayed values for sliders
        pixelSizeInput.addEventListener('input', () => {
            pixelSizeValue.textContent = pixelSizeInput.value;
        });
        
        gridOpacityInput.addEventListener('input', () => {
            gridOpacityValue.textContent = gridOpacityInput.value + '%';
        });
        
        processBtn.addEventListener('click', processImage);
        
        // Check for saved image on page load
        checkForSavedImage();
        
        function checkForSavedImage() {
            const savedImage = localStorage.getItem('pixelatedImage');
            if (savedImage) {
                const img = new Image();
                img.onload = function() {
                    pixelateImage(img, true);
                };
                img.src = savedImage;
                
                // Also restore the slider values if they were saved
                const savedSettings = localStorage.getItem('pixelatorSettings');
                if (savedSettings) {
                    const settings = JSON.parse(savedSettings);
                    pixelSizeInput.value = settings.pixelSize;
                    pixelSizeValue.textContent = settings.pixelSize;
                    gridOpacityInput.value = settings.gridOpacity;
                    gridOpacityValue.textContent = settings.gridOpacity + '%';
                }
            }
        }
        
        function processImage() {
            const file = imageInput.files[0];
            if (!file) {
                alert('Please select an image first');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    // Save the original image to localStorage
                    localStorage.setItem('pixelatedImage', e.target.result);
                    
                    // Save the current settings
                    const settings = {
                        pixelSize: pixelSizeInput.value,
                        gridOpacity: gridOpacityInput.value
                    };
                    localStorage.setItem('pixelatorSettings', JSON.stringify(settings));
                    
                    pixelateImage(img);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        // Rest of your existing functions (pixelateImage, getAverageColor) remain the same
        function pixelateImage(img, fromStorage = false) {
            const pixelSize = parseInt(pixelSizeInput.value);
            const gridOpacity = parseInt(gridOpacityInput.value) / 100;
            
            // Set canvas dimensions
            if (img.width < 299) var width = img.width+675;
            else if(img.width < 399) var width = img.width+575;
            else if(img.width < 499) var width = img.width+475;
            else if(img.width < 599) var width = img.width+375;
            else if(img.width < 699) var width = img.width+275;
            else if(img.width < 799) var width = img.width+175;
            else if(img.width < 899) var width = img.width+75;
            else var width = img.width;
            
            const height = img.height;
            canvas.width = width;
            canvas.height = height;
            
            // Draw original image
            ctx.drawImage(img, 0, 0, width, height);
            
            // Get image data
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // Clear the previous output
            pixelatedImageDiv.innerHTML = '';
            
            // Calculate number of rows and columns
            const cols = Math.ceil(width / pixelSize);
            const rows = Math.ceil(height / pixelSize);
            
            // Create container for the pixelated image
            const container = document.createElement('div');
            container.className = 'pixel-container';
            
            for (let y = 0; y < rows; y++) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'pixel-row';
                
                for (let x = 0; x < cols; x++) {
                    // Calculate the average color of the pixel block
                    const avgColor = getAverageColor(data, width, x * pixelSize, y * pixelSize, pixelSize);
                    
                    // Create pixel element
                    const pixel = document.createElement('div');
                    pixel.className = 'pixel';
                    pixel.style.width = `${pixelSize}px`;
                    pixel.style.height = `${pixelSize}px`;
                    pixel.style.backgroundColor = `rgba(${avgColor.r}, ${avgColor.g}, ${avgColor.b}, ${avgColor.a})`;
                    pixel.style.borderColor = `rgba(0, 0, 0, ${gridOpacity})`;
                    
                    rowDiv.appendChild(pixel);
                }
                
                // Add checkbox at the end of the row
                const checkboxContainer = document.createElement('div');
                checkboxContainer.className = 'checkbox-container';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `row-${y}`;
                //ide kéne valami onchange
                
                const label = document.createElement('label');
                label.htmlFor = `row-${y}`;
                label.textContent = `${y + 1}`;
                
                checkboxContainer.appendChild(checkbox);
                checkboxContainer.appendChild(label);
                rowDiv.appendChild(checkboxContainer);
                
                container.appendChild(rowDiv);
            }
            
            pixelatedImageDiv.appendChild(container);
        }
        
        function getAverageColor(data, width, startX, startY, blockSize) {
            let r = 0, g = 0, b = 0, a = 0;
            let count = 0;
            
            for (let y = startY; y < startY + blockSize; y++) {
                for (let x = startX; x < startX + blockSize; x++) {
                    const index = (y * width + x) * 4;  //4, mert így fér bele pont a gridbe a kép
                    
                    // Skip if we're outside the image bounds
                    if (index >= data.length - 3) continue;
                    
                    r += data[index];
                    g += data[index + 1];
                    b += data[index + 2];
                    a += data[index + 3];
                    count++;
                }
            }
            
            return {
                r: Math.round(r / count),
                g: Math.round(g / count),
                b: Math.round(b / count),
                a: a / count / 255
            };
        }

        function checkedBox() { //nem csinál semmit
            const pixelSize = parseInt(pixelSizeInput.value);
            const height = img.height;
            const rows = Math.ceil(height / pixelSize);
            for (let i = 0; i < rows; i++) {
                if (`row-${y}`.checked == true) {
                    console.log(igen);
                }
            }
        }

        document.getElementById('clearBtn').addEventListener('click', function() {
            // For localStorage version:
            localStorage.removeItem('pixelatedImage');
            localStorage.removeItem('pixelatorSettings');
            pixelatedImageDiv.innerHTML = '';
            imageInput.value = '';
                
            // For IndexedDB version:
            // const transaction = db.transaction(['images', 'settings'], 'readwrite');
            // transaction.objectStore('images').delete(1);
            // transaction.objectStore('settings').delete(1);
            // pixelatedImageDiv.innerHTML = '';
            // imageInput.value = '';
        });
    });

        
    </script>
</body>
</html>